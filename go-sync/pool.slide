Golang 优化之路——临时对象池

SenseTime
xingcuntian
xingcuntian@sensetime.com

* 简单实例

- 在高并发的情况下，如果每次请求都需要申请一块用于计算的内存
  make([]int64, 0, len(ids))
  make([]int64, 0)

- 第一次分配内存相当于没有分配，如果要后续append元素，会引起slice以指数形式扩充，可以参考下面的代码，追加了3个元素，slice扩容了3次。

 a := make([]int64, 0)
 fmt.Println(cap(a), len(a))
 for i := 0; i < 3; i++ {
  a = append(a, 1)
  fmt.Println(cap(a), len(a))
 }

- 每一次扩容空间，都是会重新申请一块区域，把就空间里面的元素复制进来，把新的追加进来。那旧空间里面的元素怎么办？等着垃圾回收呗。
- 简单的优化方式，就是给自己要用的slice提前申请好空间。
 make([]int64, 0, len(ids))   //这样做避免了slice多次扩容申请内存，但还是有问题的。


* 堆还是栈
- 程序会从操作系统申请一块内存，而这块内存也会被分成堆和栈。栈可以简单得理解成一次函数调用内部申请到的内存，它们会随着函数的返回把内存还给系统。
  func F() {
   temp := make([]int, 0, 20)
   ..
  }
- temp变量，只是内函数内部申请的临时变量，并不会作为返回值返回，它就是被编译器申请到栈里面。申请到栈内存好处：“函数返回直接释放，不会引起垃圾回收，对性能没有影响”。
 func F() []int{
  a := make([]int, 0, 20)
  return a
 }
- a 变量，申请的代码一模一样，但是申请后作为返回值返回了，编译器会认为变量之后还会被使用，当函数返回之后并不会将其内存归还，那么它就会被申请到堆上面了。“申请到堆上面的内存才会引起垃圾回收”。
* 堆还是栈
 func F() {
  a := make([]int, 0, 20)
  b := make([]int, 0, 20000)

  l := 20
  c := make([]int, 0, l)
 }
- a和b代码一样，申请的空间大小不同，但是两个的命运是截然相反的。a前面已经介绍过，会申请到栈上面，而b，由于申请的内存较大，编译器会把这种申请内存较大的变量转移到堆上面。即使是临时变量，申请过大也会在堆上面申请。

- 而c，对我们而言其含义和a是一致的，但是编译器对于这种不定长度的申请方式，也会在堆上面申请，即使申请的长度很短。
- 通过下面的命令查看变量申请的位置
 go build -gcflags='-m' . 2>&1

* 内存碎片化
- 实际项目基本都是通过c := make([]int, 0, l)来申请内存，长度都是不确定的。自然而然这些变量都会申请到堆上面了。Golang使用的垃圾回收算法是『标记——清除』。简单得说，就是程序要从操作系统申请一块比较大的内存，内存分成小块，通过链表链接。每次程序申请内存，就从链表上面遍历每一小块，找到符合的就返回其地址，没有合适的就从操作系统再申请。如果申请内存次数较多，而且申请的大小不固定，就会引起内存碎片化的问题。申请的堆内存并没有用完，但是用户申请的内存的时候却没有合适的空间提供。这样会遍历整个链表，还会继续向操作系统申请内存。这就能解释我一开始描述的问题，申请一块内存变成了慢语句
* 临时对象池
- Golang在sync里面提供了对象池Pool。临时对象池。因为每次垃圾回收会把池子里面不被引用的对象回收掉。
- 需要注意的是，Get方法会把返回的对象从池子里面删除。所以用完了的对象，还是得重新放回池子
https://github.com/funny/slab/blob/master/sync_pool.go

* sync.Pool

 sync.Pool在高并发情况下使用是非常普遍的。你可能会创建大量的goroutines，并且它们每个都分配短暂的对象，然后导致GC速度缓慢。
 随着sync.Pool我们能够避免这种情况。GC内部的对象在GC之后将被清除而没有任何通知，因此sync.Pool不适合连接池。
 在GC发生之前，Put()回到池中的对象可能会被Get()重用。这意味着您有机会获得Get()具有旧值的对象。
